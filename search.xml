<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go安全指南</title>
      <link href="/2021/06/26/go-an-quan-zhi-nan/"/>
      <url>/2021/06/26/go-an-quan-zhi-nan/</url>
      
        <content type="html"><![CDATA[<!-- markdown="1" is required for GitHub Pages to render the TOC properly. --><details markdown="1">  <summary>目录</summary><ul><li><p><a href="#1">1 通用类</a></p><ul><li><a href="#1.1">I. 代码实现</a><ul><li><a href="#1.1.1">1.1 内存管理</a></li><li><a href="#1.1.2">1.2 文件操作</a></li><li><a href="#1.1.3">1.3 系统接口</a></li><li><a href="#1.1.4">1.4 通信安全</a></li><li><a href="#1.1.5">1.5 敏感数据保护</a></li><li><a href="#1.1.6">1.6 加密解密</a></li><li><a href="#1.1.7">1.7 正则表达式</a></li></ul></li></ul></li><li><p><a href="#2">2 后台类</a></p><ul><li><a href="#2.1">I. 代码实现</a><ul><li><a href="#2.1.1">1.1 输入校验</a></li><li><a href="#2.1.2">1.2 SQL 操作</a></li><li><a href="#2.1.3">1.3 网络请求</a></li><li><a href="#2.1.4">1.4 服务器端渲染</a></li><li><a href="#2.1.5">1.5 Web 跨域</a></li><li><a href="#2.1.6">1.6 响应输出</a></li><li><a href="#2.1.7">1.7 会话管理</a></li><li><a href="#2.1.8">1.8 访问控制</a></li><li><a href="#2.1.9">1.9 并发保护</a></details></li></ul></li></ul></li></ul><p><a id="1"></a></p><h1 id="通用类"><a href="#通用类" class="headerlink" title="通用类"></a>通用类</h1><p><a id="1.1"></a></p><h2 id="1-代码实现类"><a href="#1-代码实现类" class="headerlink" title="1. 代码实现类"></a>1. 代码实现类</h2><p><a id="1.1.1"></a></p><h3 id="1-1-内存管理"><a href="#1-1-内存管理" class="headerlink" title="1.1 内存管理"></a>1.1 内存管理</h3><h4 id="1-1-1【必须】切片长度校验"><a href="#1-1-1【必须】切片长度校验" class="headerlink" title="1.1.1【必须】切片长度校验"></a>1.1.1【必须】切片长度校验</h4><ul><li>在对 slice 进行操作时，必须判断长度是否合法，防止程序 panic</li></ul><pre><code class="go">// bad: 未判断data的长度，可导致 index out of rangefunc decode(data []byte) bool &#123;    if data[0] == &#39;F&#39; &amp;&amp; data[1] == &#39;U&#39; &amp;&amp; data[2] == &#39;Z&#39; &amp;&amp; data[3] == &#39;Z&#39; &amp;&amp; data[4] == &#39;E&#39; &amp;&amp; data[5] == &#39;R&#39; &#123;        fmt.Println(&quot;Bad&quot;)        return true    &#125;    return false&#125;// bad: slice bounds out of rangefunc foo() &#123;    var slice = []int&#123;0, 1, 2, 3, 4, 5, 6&#125;    fmt.Println(slice[:10])&#125;// good: 使用data前应判断长度是否合法func decode(data []byte) bool &#123;    if len(data) == 6 &#123;        if data[0] == &#39;F&#39; &amp;&amp; data[1] == &#39;U&#39; &amp;&amp; data[2] == &#39;Z&#39; &amp;&amp; data[3] == &#39;Z&#39; &amp;&amp; data[4] == &#39;E&#39; &amp;&amp; data[5] == &#39;R&#39; &#123;            fmt.Println(&quot;Good&quot;)            return true        &#125;    &#125;    return false&#125;</code></pre><h4 id="1-1-2【必须】nil-指针判断"><a href="#1-1-2【必须】nil-指针判断" class="headerlink" title="1.1.2【必须】nil 指针判断"></a>1.1.2【必须】nil 指针判断</h4><ul><li>进行指针操作时，必须判断该指针是否为 nil，防止程序 panic，尤其在进行结构体 Unmarshal 时</li></ul><pre><code class="go">type Packet struct &#123;    PackeyType    uint8    PackeyVersion uint8    Data          *Data&#125;type Data struct &#123;    Stat uint8    Len  uint8    Buf  [8]byte&#125;func (p *Packet) UnmarshalBinary(b []byte) error &#123;    if len(b) &lt; 2 &#123;        return io.EOF    &#125;    p.PackeyType = b[0]    p.PackeyVersion = b[1]    // 若长度等于2，那么不会new Data    if len(b) &gt; 2 &#123;        p.Data = new(Data)    &#125;    return nil&#125;// bad: 未判断指针是否为nilfunc main() &#123;    packet := new(Packet)    data := make([]byte, 2)    if err := packet.UnmarshalBinary(data); err != nil &#123;        fmt.Println(&quot;Failed to unmarshal packet&quot;)        return    &#125;    fmt.Printf(&quot;Stat: %v\n&quot;, packet.Data.Stat)&#125;// good: 判断Data指针是否为nilfunc main() &#123;    packet := new(Packet)    data := make([]byte, 2)    if err := packet.UnmarshalBinary(data); err != nil &#123;        fmt.Println(&quot;Failed to unmarshal packet&quot;)        return    &#125;    if packet.Data == nil &#123;        return    &#125;    fmt.Printf(&quot;Stat: %v\n&quot;, packet.Data.Stat)&#125;</code></pre><h4 id="1-1-3【必须】整数安全"><a href="#1-1-3【必须】整数安全" class="headerlink" title="1.1.3【必须】整数安全"></a>1.1.3【必须】整数安全</h4><ul><li><p>在进行数字运算操作时，需要做好长度限制，防止外部输入运算导致异常：</p><ul><li>确保无符号整数运算时不会反转</li><li>确保有符号整数运算时不会出现溢出</li><li>确保整型转换时不会出现截断错误</li><li>确保整型转换时不会出现符号错误</li></ul></li><li><p>以下场景必须严格进行长度限制：</p><ul><li>作为数组索引</li><li>作为对象的长度或者大小</li><li>作为数组的边界（如作为循环计数器）</li></ul></li></ul><pre><code class="go">// bad: 未限制长度，导致整数溢出func overflow(numControlByUser int32) &#123;    var numInt int32 = 0    numInt = numControlByUser + 1    // 对长度限制不当，导致整数溢出    fmt.Printf(&quot;%d\n&quot;, numInt)    // 使用numInt，可能导致其他错误&#125;func main() &#123;    overflow(2147483647)&#125;// goodfunc overflow(numControlByUser int32) &#123;    var numInt int32 = 0    numInt = numControlByUser + 1    if numInt &lt; 0 &#123;        fmt.Println(&quot;integer overflow&quot;)        return    &#125;    fmt.Println(&quot;integer ok&quot;)&#125;func main() &#123;    overflow(2147483647)&#125;</code></pre><h4 id="1-1-4【必须】make-分配长度验证"><a href="#1-1-4【必须】make-分配长度验证" class="headerlink" title="1.1.4【必须】make 分配长度验证"></a>1.1.4【必须】make 分配长度验证</h4><ul><li>在进行 make 分配内存时，需要对外部可控的长度进行校验，防止程序 panic。</li></ul><pre><code class="go">// badfunc parse(lenControlByUser int, data []byte) &#123;    size := lenControlByUser    // 对外部传入的size，进行长度判断以免导致panic    buffer := make([]byte, size)    copy(buffer, data)&#125;// goodfunc parse(lenControlByUser int, data []byte) ([]byte, error) &#123;    size := lenControlByUser    // 限制外部可控的长度大小范围    if size &gt; 64*1024*1024 &#123;        return nil, errors.New(&quot;value too large&quot;)    &#125;    buffer := make([]byte, size)    copy(buffer, data)    return buffer, nil&#125;</code></pre><h4 id="1-1-5【必须】禁止-SetFinalizer-和指针循环引用同时使用"><a href="#1-1-5【必须】禁止-SetFinalizer-和指针循环引用同时使用" class="headerlink" title="1.1.5【必须】禁止 SetFinalizer 和指针循环引用同时使用"></a>1.1.5【必须】禁止 SetFinalizer 和指针循环引用同时使用</h4><ul><li>当一个对象从被 GC 选中到移除内存之前，runtime.SetFinalizer()都不会执行，即使程序正常结束或者发生错误。由指针构成的“循环引用”虽然能被 GC 正确处理，但由于无法确定 Finalizer 依赖顺序，从而无法调用 runtime.SetFinalizer()，导致目标对象无法变成可达状态，从而造成内存无法被回收。</li></ul><pre><code class="go">// badfunc foo() &#123;    var a, b Data    a.o = &amp;b    b.o = &amp;a    // 指针循环引用，SetFinalizer()无法正常调用    runtime.SetFinalizer(&amp;a, func(d *Data) &#123;        fmt.Printf(&quot;a %p final.\n&quot;, d)    &#125;)    runtime.SetFinalizer(&amp;b, func(d *Data) &#123;        fmt.Printf(&quot;b %p final.\n&quot;, d)    &#125;)&#125;func main() &#123;    for &#123;        foo()        time.Sleep(time.Millisecond)    &#125;&#125;</code></pre><h4 id="1-1-6【必须】禁止重复释放-channel"><a href="#1-1-6【必须】禁止重复释放-channel" class="headerlink" title="1.1.6【必须】禁止重复释放 channel"></a>1.1.6【必须】禁止重复释放 channel</h4><ul><li>重复释放一般存在于异常流程判断中，如果恶意攻击者构造出异常条件使程序重复释放 channel，则会触发运行时 panic，从而造成 DoS 攻击。</li></ul><pre><code class="go">// badfunc foo(c chan int) &#123;    defer close(c)    err := processBusiness()    if err != nil &#123;        c &lt;- 0        close(c) // 重复释放channel        return    &#125;    c &lt;- 1&#125;// goodfunc foo(c chan int) &#123;    defer close(c) // 使用defer延迟关闭channel    err := processBusiness()    if err != nil &#123;        c &lt;- 0        return    &#125;    c &lt;- 1&#125;</code></pre><h4 id="1-1-7【必须】确保每个协程都能退出"><a href="#1-1-7【必须】确保每个协程都能退出" class="headerlink" title="1.1.7【必须】确保每个协程都能退出"></a>1.1.7【必须】确保每个协程都能退出</h4><ul><li>启动一个协程就会做一个入栈操作，在系统不退出的情况下，协程也没有设置退出条件，则相当于协程失去了控制，它占用的资源无法回收，可能会导致内存泄露。</li></ul><pre><code class="go">// bad: 协程没有设置退出条件func doWaiter(name string, second int) &#123;    for &#123;        time.Sleep(time.Duration(second) * time.Second)        fmt.Println(name, &quot; is ready!&quot;)    &#125;&#125;</code></pre><h4 id="1-1-8【推荐】不使用-unsafe-包"><a href="#1-1-8【推荐】不使用-unsafe-包" class="headerlink" title="1.1.8【推荐】不使用 unsafe 包"></a>1.1.8【推荐】不使用 unsafe 包</h4><ul><li>由于 unsafe 包绕过了 Golang 的内存安全原则，一般来说使用该库是不安全的，可导致内存破坏，尽量避免使用该包。若必须要使用 unsafe 操作指针，必须做好安全校验。</li></ul><pre><code class="go">// bad: 通过unsafe操作原始指针func unsafePointer() &#123;    b := make([]byte, 1)    foo := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;b[0])) + uintptr(0xfffffffe)))    fmt.Print(*foo + 1)&#125;// [signal SIGSEGV: segmentation violation code=0x1 addr=0xc100068f55 pc=0x49142b]</code></pre><h4 id="1-1-9【推荐】不使用-slice-作为函数入参"><a href="#1-1-9【推荐】不使用-slice-作为函数入参" class="headerlink" title="1.1.9【推荐】不使用 slice 作为函数入参"></a>1.1.9【推荐】不使用 slice 作为函数入参</h4><ul><li>slice 是引用类型，在作为函数入参时采用的是地址传递，对 slice 的修改也会影响原始数据</li></ul><pre><code class="go">// bad: slice作为函数入参时是地址传递func modify(array []int) &#123;    array[0] = 10 // 对入参slice的元素修改会影响原始数据&#125;func main() &#123;    array := []int&#123;1, 2, 3, 4, 5&#125;    modify(array)    fmt.Println(array) // output：[10 2 3 4 5]&#125;// good: 函数使用数组作为入参，而不是slicefunc modify(array [5]int) &#123;    array[0] = 10&#125;func main() &#123;    // 传入数组，注意数组与slice的区别    array := [5]int&#123;1, 2, 3, 4, 5&#125;    modify(array)    fmt.Println(array)&#125;</code></pre><p><a id="1.1.2"></a></p><h3 id="1-2-文件操作"><a href="#1-2-文件操作" class="headerlink" title="1.2 文件操作"></a>1.2 文件操作</h3><h4 id="1-2-1【必须】-路径穿越检查"><a href="#1-2-1【必须】-路径穿越检查" class="headerlink" title="1.2.1【必须】 路径穿越检查"></a>1.2.1【必须】 路径穿越检查</h4><ul><li>在进行文件操作时，如果对外部传入的文件名未做限制，可能导致任意文件读取或者任意文件写入，严重可能导致代码执行。</li></ul><pre><code class="go">// bad: 任意文件读取func handler(w http.ResponseWriter, r *http.Request) &#123;    path := r.URL.Query()[&quot;path&quot;][0]    // 未过滤文件路径，可能导致任意文件读取    data, _ := ioutil.ReadFile(path)    w.Write(data)    // 对外部传入的文件名变量，还需要验证是否存在../等路径穿越的文件名    data, _ = ioutil.ReadFile(filepath.Join(&quot;/home/user/&quot;, path))    w.Write(data)&#125;// bad: 任意文件写入func unzip(f string) &#123;    r, _ := zip.OpenReader(f)    for _, f := range r.File &#123;        p, _ := filepath.Abs(f.Name)        // 未验证压缩文件名，可能导致../等路径穿越，任意文件路径写入        ioutil.WriteFile(p, []byte(&quot;present&quot;), 0640)    &#125;&#125;// good: 检查压缩的文件名是否包含..路径穿越特征字符，防止任意写入func unzipGood(f string) bool &#123;    r, err := zip.OpenReader(f)    if err != nil &#123;        fmt.Println(&quot;read zip file fail&quot;)        return false    &#125;    for _, f := range r.File &#123;        if !strings.Contains(f.Name, &quot;..&quot;) &#123;            p, _ := filepath.Abs(f.Name)            ioutil.WriteFile(p, []byte(&quot;present&quot;), 0640)        &#125; else &#123;            return false        &#125;    &#125;    return true&#125;</code></pre><h4 id="1-2-2【必须】-文件访问权限"><a href="#1-2-2【必须】-文件访问权限" class="headerlink" title="1.2.2【必须】 文件访问权限"></a>1.2.2【必须】 文件访问权限</h4><ul><li>根据创建文件的敏感性设置不同级别的访问权限，以防止敏感数据被任意权限用户读取。例如，设置文件权限为：<code>-rw-r-----</code></li></ul><pre><code class="go">ioutil.WriteFile(p, []byte(&quot;present&quot;), 0640)</code></pre><p><a id="1.1.3"></a></p><h3 id="1-3-系统接口"><a href="#1-3-系统接口" class="headerlink" title="1.3 系统接口"></a>1.3 系统接口</h3><p><strong>1.3.1【必须】命令执行检查</strong></p><ul><li>使用<code>exec.Command</code>、<code>exec.CommandContext</code>、<code>syscall.StartProcess</code>、<code>os.StartProcess</code>等函数时，第一个参数（path）直接取外部输入值时，应使用白名单限定可执行的命令范围，不允许传入<code>bash</code>、<code>cmd</code>、<code>sh</code>等命令；</li><li>使用<code>exec.Command</code>、<code>exec.CommandContext</code>等函数时，通过<code>bash</code>、<code>cmd</code>、<code>sh</code>等创建 shell，-c 后的参数（arg）拼接外部输入，应过滤\n $ &amp; ; | ‘ “ ( ) `等潜在恶意字符；</li></ul><pre><code class="go">// badfunc foo() &#123;    userInputedVal := &quot;&amp;&amp; echo &#39;hello&#39;&quot; // 假设外部传入该变量值    cmdName := &quot;ping &quot; + userInputedVal    // 未判断外部输入是否存在命令注入字符，结合sh可造成命令注入    cmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, cmdName)    output, _ := cmd.CombinedOutput()    fmt.Println(string(output))    cmdName := &quot;ls&quot;    // 未判断外部输入是否是预期命令    cmd := exec.Command(cmdName)    output, _ := cmd.CombinedOutput()    fmt.Println(string(output))&#125;// goodfunc checkIllegal(cmdName string) bool &#123;    if strings.Contains(cmdName, &quot;&amp;&quot;) || strings.Contains(cmdName, &quot;|&quot;) || strings.Contains(cmdName, &quot;;&quot;) ||        strings.Contains(cmdName, &quot;$&quot;) || strings.Contains(cmdName, &quot;&#39;&quot;) || strings.Contains(cmdName, &quot;`&quot;) ||        strings.Contains(cmdName, &quot;(&quot;) || strings.Contains(cmdName, &quot;)&quot;) || strings.Contains(cmdName, &quot;\&quot;&quot;) &#123;        return true    &#125;    return false&#125;func main() &#123;    userInputedVal := &quot;&amp;&amp; echo &#39;hello&#39;&quot;    cmdName := &quot;ping &quot; + userInputedVal    if checkIllegal(cmdName) &#123; // 检查传给sh的命令是否有特殊字符        return // 存在特殊字符直接return    &#125;    cmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, cmdName)    output, _ := cmd.CombinedOutput()    fmt.Println(string(output))&#125;</code></pre><p><a id="1.1.4"></a></p><h3 id="1-4-通信安全"><a href="#1-4-通信安全" class="headerlink" title="1.4 通信安全"></a>1.4 通信安全</h3><h4 id="1-4-1【必须】网络通信采用-TLS-方式"><a href="#1-4-1【必须】网络通信采用-TLS-方式" class="headerlink" title="1.4.1【必须】网络通信采用 TLS 方式"></a>1.4.1【必须】网络通信采用 TLS 方式</h4><ul><li>明文传输的通信协议目前已被验证存在较大安全风险，被中间人劫持后可能导致许多安全风险，因此必须采用至少 TLS 的安全通信方式保证通信安全，例如 gRPC/Websocket 都使用 TLS1.3。</li></ul><pre><code class="go">// goodfunc main() &#123;    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, req *http.Request) &#123;        w.Header().Add(&quot;Strict-Transport-Security&quot;, &quot;max-age=63072000; includeSubDomains&quot;)        w.Write([]byte(&quot;This is an example server.\n&quot;))    &#125;)    // 服务器配置证书与私钥    log.Fatal(http.ListenAndServeTLS(&quot;:443&quot;, &quot;yourCert.pem&quot;, &quot;yourKey.pem&quot;, nil))&#125;</code></pre><h4 id="1-4-2【推荐】TLS-启用证书验证"><a href="#1-4-2【推荐】TLS-启用证书验证" class="headerlink" title="1.4.2【推荐】TLS 启用证书验证"></a>1.4.2【推荐】TLS 启用证书验证</h4><ul><li>TLS 证书应当是有效的、未过期的，且配置正确的域名，生产环境的服务端应启用证书验证。</li></ul><pre><code class="go">// badimport (    &quot;crypto/tls&quot;    &quot;net/http&quot;)func doAuthReq(authReq *http.Request) *http.Response &#123;    tr := &amp;http.Transport&#123;        TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: true&#125;,    &#125;    client := &amp;http.Client&#123;Transport: tr&#125;    res, _ := client.Do(authReq)    return res&#125;// goodimport (    &quot;crypto/tls&quot;    &quot;net/http&quot;)func doAuthReq(authReq *http.Request) *http.Response &#123;    tr := &amp;http.Transport&#123;        TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: false&#125;,    &#125;    client := &amp;http.Client&#123;Transport: tr&#125;    res, _ := client.Do(authReq)    return res&#125;</code></pre><p><a id="1.1.5"></a></p><h3 id="1-5-敏感数据保护"><a href="#1-5-敏感数据保护" class="headerlink" title="1.5 敏感数据保护"></a>1.5 敏感数据保护</h3><h4 id="1-5-1【必须】敏感信息访问"><a href="#1-5-1【必须】敏感信息访问" class="headerlink" title="1.5.1【必须】敏感信息访问"></a>1.5.1【必须】敏感信息访问</h4><ul><li>禁止将敏感信息硬编码在程序中，既可能会将敏感信息暴露给攻击者，也会增加代码管理和维护的难度</li><li>使用配置中心系统统一托管密钥等敏感信息</li></ul><h4 id="1-5-2【必须】敏感数据输出"><a href="#1-5-2【必须】敏感数据输出" class="headerlink" title="1.5.2【必须】敏感数据输出"></a>1.5.2【必须】敏感数据输出</h4><ul><li>只输出必要的最小数据集，避免多余字段暴露引起敏感信息泄露</li><li>不能在日志保存密码（包括明文密码和密文密码）、密钥和其它敏感信息</li><li>对于必须输出的敏感信息，必须进行合理脱敏展示</li></ul><pre><code class="go">// badfunc serve() &#123;    http.HandleFunc(&quot;/register&quot;, func(w http.ResponseWriter, r *http.Request) &#123;        r.ParseForm()        user := r.Form.Get(&quot;user&quot;)        pw := r.Form.Get(&quot;password&quot;)        log.Printf(&quot;Registering new user %s with password %s.\n&quot;, user, pw)    &#125;)    http.ListenAndServe(&quot;:80&quot;, nil)&#125;// goodfunc serve1() &#123;    http.HandleFunc(&quot;/register&quot;, func(w http.ResponseWriter, r *http.Request) &#123;        r.ParseForm()        user := r.Form.Get(&quot;user&quot;)        pw := r.Form.Get(&quot;password&quot;)        log.Printf(&quot;Registering new user %s.\n&quot;, user)        // ...        use(pw)    &#125;)    http.ListenAndServe(&quot;:80&quot;, nil)&#125;</code></pre><ul><li>避免通过 GET 方法、代码注释、自动填充、缓存等方式泄露敏感信息</li></ul><h4 id="1-5-3【必须】敏感数据存储"><a href="#1-5-3【必须】敏感数据存储" class="headerlink" title="1.5.3【必须】敏感数据存储"></a>1.5.3【必须】敏感数据存储</h4><ul><li>敏感数据应使用 SHA2、RSA 等算法进行加密存储</li><li>敏感数据应使用独立的存储层，并在访问层开启访问控制</li><li>包含敏感信息的临时文件或缓存一旦不再需要应立刻删除</li></ul><h4 id="1-5-4【必须】异常处理和日志记录"><a href="#1-5-4【必须】异常处理和日志记录" class="headerlink" title="1.5.4【必须】异常处理和日志记录"></a>1.5.4【必须】异常处理和日志记录</h4><ul><li>应合理使用 panic、recover、defer 处理系统异常，避免出错信息输出到前端</li></ul><pre><code class="go">defer func () &#123;    if r := recover(); r != nil &#123;        fmt.Println(&quot;Recovered in start()&quot;)    &#125;&#125;()</code></pre><ul><li>对外环境禁止开启 debug 模式，或将程序运行日志输出到前端</li></ul><pre><code class="bash">// baddlv --listen=:2345 --headless=true --api-version=2 debug test.go// gooddlv debug test.go</code></pre><p><a id="1.1.6"></a></p><h3 id="1-6-加密解密"><a href="#1-6-加密解密" class="headerlink" title="1.6 加密解密"></a>1.6 加密解密</h3><h4 id="1-6-1【必须】不得硬编码密码-密钥"><a href="#1-6-1【必须】不得硬编码密码-密钥" class="headerlink" title="1.6.1【必须】不得硬编码密码/密钥"></a>1.6.1【必须】不得硬编码密码/密钥</h4><ul><li>在进行用户登陆，加解密算法等操作时，不得在代码里硬编码密钥或密码，可通过变换算法或者配置等方式设置密码或者密钥。</li></ul><pre><code class="go">// badconst (    user     = &quot;dbuser&quot;    password = &quot;s3cretp4ssword&quot;)func connect() *sql.DB &#123;    connStr := fmt.Sprintf(&quot;postgres://%s:%s@localhost/pqgotest&quot;, user, password)    db, err := sql.Open(&quot;postgres&quot;, connStr)    if err != nil &#123;        return nil    &#125;    return db&#125;// badvar (    commonkey = []byte(&quot;0123456789abcdef&quot;))func AesEncrypt(plaintext string) (string, error) &#123;    block, err := aes.NewCipher(commonkey)    if err != nil &#123;        return &quot;&quot;, err    &#125;&#125;</code></pre><h4 id="1-6-2【必须】密钥存储安全"><a href="#1-6-2【必须】密钥存储安全" class="headerlink" title="1.6.2【必须】密钥存储安全"></a>1.6.2【必须】密钥存储安全</h4><ul><li>在使用对称密码算法时，需要保护好加密密钥。当算法涉及敏感、业务数据时，可通过非对称算法协商加密密钥。其他较为不敏感的数据加密，可以通过变换算法等方式保护密钥。</li></ul><h4 id="1-6-3【推荐】不使用弱密码算法"><a href="#1-6-3【推荐】不使用弱密码算法" class="headerlink" title="1.6.3【推荐】不使用弱密码算法"></a>1.6.3【推荐】不使用弱密码算法</h4><ul><li>在使用加密算法时，不建议使用加密强度较弱的算法。</li></ul><pre><code>// badcrypto/des，crypto/md5，crypto/sha1，crypto/rc4等。// goodcrypto/rsa，crypto/aes等。</code></pre><p><a id="1.1.7"></a></p><h3 id="1-7-正则表达式"><a href="#1-7-正则表达式" class="headerlink" title="1.7 正则表达式"></a>1.7 正则表达式</h3><h4 id="1-7-1【推荐】使用-regexp-进行正则表达式匹配"><a href="#1-7-1【推荐】使用-regexp-进行正则表达式匹配" class="headerlink" title="1.7.1【推荐】使用 regexp 进行正则表达式匹配"></a>1.7.1【推荐】使用 regexp 进行正则表达式匹配</h4><ul><li>正则表达式编写不恰当可被用于 DoS 攻击，造成服务不可用，推荐使用 regexp 包进行正则表达式匹配。regexp 保证了线性时间性能和优雅的失败：对解析器、编译器和执行引擎都进行了内存限制。但 regexp 不支持以下正则表达式特性，如业务依赖这些特性，则 regexp 不适合使用。<ul><li>回溯引用<a href="https://www.regular-expressions.info/backref.html">Backreferences</a></li><li>查看<a href="https://www.regular-expressions.info/lookaround.html">Lookaround</a></li></ul></li></ul><pre><code class="go">// goodmatched, err := regexp.MatchString(`a.b`, &quot;aaxbb&quot;)fmt.Println(matched) // truefmt.Println(err)     // nil</code></pre><p><a id="2"></a></p><h1 id="后台类"><a href="#后台类" class="headerlink" title="后台类"></a>后台类</h1><p><a id="2.1"></a></p><h2 id="1-代码实现类-1"><a href="#1-代码实现类-1" class="headerlink" title="1 代码实现类"></a>1 代码实现类</h2><p><a id="2.1.1"></a></p><h3 id="1-1-输入校验"><a href="#1-1-输入校验" class="headerlink" title="1.1 输入校验"></a>1.1 输入校验</h3><h4 id="1-1-1【必须】按类型进行数据校验"><a href="#1-1-1【必须】按类型进行数据校验" class="headerlink" title="1.1.1【必须】按类型进行数据校验"></a>1.1.1【必须】按类型进行数据校验</h4><ul><li>所有外部输入的参数，应使用<code>validator</code>进行白名单校验，校验内容包括但不限于数据长度、数据范围、数据类型与格式，校验不通过的应当拒绝</li></ul><pre><code class="go">// goodimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)var validate *validator.Validatefunc validateVariable() &#123;    myEmail := &quot;abc@tencent.com&quot;    errs := validate.Var(myEmail, &quot;required,email&quot;)    if errs != nil &#123;        fmt.Println(errs)        return        //停止执行    &#125;    // 验证通过，继续执行    ...&#125;func main() &#123;    validate = validator.New()    validateVariable()&#125;</code></pre><ul><li>无法通过白名单校验的应使用<code>html.EscapeString</code>、<code>text/template</code>或<code>bluemonday</code>对<code>&lt;, &gt;, &amp;, &#39;,&quot;</code>等字符进行过滤或编码</li></ul><pre><code class="go">import (    &quot;text/template&quot;)// TestHTMLEscapeString HTML特殊字符转义func main(inputValue string) string &#123;    escapedResult := template.HTMLEscapeString(inputValue)    return escapedResult&#125;</code></pre><p><a id="2.1.2"></a></p><h3 id="1-2-SQL-操作"><a href="#1-2-SQL-操作" class="headerlink" title="1.2 SQL 操作"></a>1.2 SQL 操作</h3><h4 id="1-2-1【必须】SQL-语句默认使用预编译并绑定变量"><a href="#1-2-1【必须】SQL-语句默认使用预编译并绑定变量" class="headerlink" title="1.2.1【必须】SQL 语句默认使用预编译并绑定变量"></a>1.2.1【必须】SQL 语句默认使用预编译并绑定变量</h4><ul><li>使用<code>database/sql</code>的 prepare、Query 或使用 GORM 等 ORM 执行 SQL 操作</li></ul><pre><code class="go">import (    &quot;github.com/jinzhu/gorm&quot;    _ &quot;github.com/jinzhu/gorm/dialects/sqlite&quot;)type Product struct &#123;    gorm.Model    Code  string    Price uint&#125;...var product Product...db.First(&amp;product, 1)</code></pre><ul><li>使用参数化查询，禁止拼接 SQL 语句，另外对于传入参数用于 order by 或表名的需要通过校验</li></ul><pre><code class="go">// badimport (    &quot;database/sql&quot;    &quot;fmt&quot;    &quot;net/http&quot;)func handler(db *sql.DB, req *http.Request) &#123;    q := fmt.Sprintf(&quot;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#39;%s&#39; ORDER BY PRICE&quot;,        req.URL.Query()[&quot;category&quot;])    db.Query(q)&#125;// goodfunc handlerGood(db *sql.DB, req *http.Request) &#123;    // 使用?占位符    q := &quot;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#39;?&#39; ORDER BY PRICE&quot;    db.Query(q, req.URL.Query()[&quot;category&quot;])&#125;</code></pre><p><a id="2.1.3"></a></p><h3 id="1-3-网络请求"><a href="#1-3-网络请求" class="headerlink" title="1.3 网络请求"></a>1.3 网络请求</h3><h4 id="1-3-1【必须】资源请求过滤验证"><a href="#1-3-1【必须】资源请求过滤验证" class="headerlink" title="1.3.1【必须】资源请求过滤验证"></a>1.3.1【必须】资源请求过滤验证</h4><ul><li><p>使用<code>&quot;net/http&quot;</code>下的方法<code>http.Get(url)</code>、<code>http.Post(url, contentType, body)</code>、<code>http.Head(url)</code>、<code>http.PostForm(url, data)</code>、<code>http.Do(req)</code>时，如变量值外部可控（指从参数中动态获取），应对请求目标进行严格的安全校验。</p></li><li><p>如请求资源域名归属固定的范围，如只允许<code>a.qq.com</code>和<code>b.qq.com</code>，应做白名单限制。如不适用白名单，则推荐的校验逻辑步骤是：</p><ul><li><p>第 1 步、只允许 HTTP 或 HTTPS 协议</p></li><li><p>第 2 步、解析目标 URL，获取其 HOST</p></li><li><p>第 3 步、解析 HOST，获取 HOST 指向的 IP 地址转换成 Long 型</p></li><li><p>第 4 步、检查 IP 地址是否为内网 IP，网段有：</p><pre><code>// 以RFC定义的专有网络为例，如有自定义私有网段亦应加入禁止访问列表。10.0.0.0/8172.16.0.0/12192.168.0.0/16127.0.0.0/8</code></pre></li><li><p>第 5 步、请求 URL</p></li><li><p>第 6 步、如有跳转，跳转后执行 1，否则绑定经校验的 ip 和域名，对 URL 发起请求</p></li></ul></li><li><p>官方库<code>encoding/xml</code>不支持外部实体引用，使用该库可避免 xxe 漏洞</p></li></ul><pre><code class="go">import (    &quot;encoding/xml&quot;    &quot;fmt&quot;    &quot;os&quot;)func main() &#123;    type Person struct &#123;        XMLName  xml.Name `xml:&quot;person&quot;`        Id       int      `xml:&quot;id,attr&quot;`        UserName string   `xml:&quot;name&gt;first&quot;`        Comment  string   `xml:&quot;,comment&quot;`    &#125;    v := &amp;Person&#123;Id: 13, UserName: &quot;John&quot;&#125;    v.Comment = &quot; Need more details. &quot;    enc := xml.NewEncoder(os.Stdout)    enc.Indent(&quot;  &quot;, &quot;    &quot;)    if err := enc.Encode(v); err != nil &#123;        fmt.Printf(&quot;error: %v\n&quot;, err)    &#125;&#125;</code></pre><p><a id="2.1.4"></a></p><h3 id="1-4-服务器端渲染"><a href="#1-4-服务器端渲染" class="headerlink" title="1.4 服务器端渲染"></a>1.4 服务器端渲染</h3><h4 id="1-4-1【必须】模板渲染过滤验证"><a href="#1-4-1【必须】模板渲染过滤验证" class="headerlink" title="1.4.1【必须】模板渲染过滤验证"></a>1.4.1【必须】模板渲染过滤验证</h4><ul><li>使用<code>text/template</code>或者<code>html/template</code>渲染模板时禁止将外部输入参数引入模板，或仅允许引入白名单内字符。</li></ul><pre><code class="go">// badfunc handler(w http.ResponseWriter, r *http.Request) &#123;    r.ParseForm()    x := r.Form.Get(&quot;name&quot;)    var tmpl = `&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;    &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;        First name:&lt;br&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;    &lt;/form&gt;&lt;p&gt;` + x + ` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`    t := template.New(&quot;main&quot;)    t, _ = t.Parse(tmpl)    t.Execute(w, &quot;Hello&quot;)&#125;// goodimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)var validate *validator.Validatevalidate = validator.New()func validateVariable(val) &#123;    errs := validate.Var(val, &quot;gte=1,lte=100&quot;) // 限制必须是1-100的正整数    if errs != nil &#123;        fmt.Println(errs)        return false    &#125;    return true&#125;func handler(w http.ResponseWriter, r *http.Request) &#123;    r.ParseForm()    x := r.Form.Get(&quot;name&quot;)    if validateVariable(x) &#123;        var tmpl = `&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;            &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;            &lt;/form&gt;&lt;p&gt;` + x + ` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`        t := template.New(&quot;main&quot;)        t, _ = t.Parse(tmpl)        t.Execute(w, &quot;Hello&quot;)    &#125; else &#123;        // ...    &#125;&#125;</code></pre><p><a id="2.1.5"></a></p><h3 id="1-5-Web-跨域"><a href="#1-5-Web-跨域" class="headerlink" title="1.5 Web 跨域"></a>1.5 Web 跨域</h3><h4 id="1-5-1【必须】跨域资源共享-CORS-限制请求来源"><a href="#1-5-1【必须】跨域资源共享-CORS-限制请求来源" class="headerlink" title="1.5.1【必须】跨域资源共享 CORS 限制请求来源"></a>1.5.1【必须】跨域资源共享 CORS 限制请求来源</h4><ul><li>CORS 请求保护不当可导致敏感信息泄漏，因此应当严格设置 Access-Control-Allow-Origin 使用同源策略进行保护。</li></ul><pre><code class="go">// goodc := cors.New(cors.Options&#123;    AllowedOrigins:   []string&#123;&quot;http://qq.com&quot;, &quot;https://qq.com&quot;&#125;,    AllowCredentials: true,    Debug:            false,&#125;)// 引入中间件handler = c.Handler(handler)</code></pre><p><a id="2.1.6"></a></p><h3 id="1-6-响应输出"><a href="#1-6-响应输出" class="headerlink" title="1.6 响应输出"></a>1.6 响应输出</h3><h4 id="1-6-1-【必须】设置正确的-HTTP-响应包类型"><a href="#1-6-1-【必须】设置正确的-HTTP-响应包类型" class="headerlink" title="1.6.1 【必须】设置正确的 HTTP 响应包类型"></a>1.6.1 【必须】设置正确的 HTTP 响应包类型</h4><ul><li>响应头 Content-Type 与实际响应内容，应保持一致。如：API 响应数据类型是 json，则响应头使用<code>application/json</code>；若为 xml，则设置为<code>text/xml</code>。</li></ul><h4 id="1-6-2-【必须】添加安全响应头"><a href="#1-6-2-【必须】添加安全响应头" class="headerlink" title="1.6.2 【必须】添加安全响应头"></a>1.6.2 【必须】添加安全响应头</h4><ul><li>所有接口、页面，添加响应头 <code>X-Content-Type-Options: nosniff</code>。</li><li>所有接口、页面，添加响应头<code>X-Frame-Options </code>。按需合理设置其允许范围，包括：<code>DENY</code>、<code>SAMEORIGIN</code>、<code>ALLOW-FROM origin</code>。用法参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options">MDN 文档</a></li></ul><h4 id="1-6-3【必须】外部输入拼接到-HTTP-响应头中需进行过滤"><a href="#1-6-3【必须】外部输入拼接到-HTTP-响应头中需进行过滤" class="headerlink" title="1.6.3【必须】外部输入拼接到 HTTP 响应头中需进行过滤"></a>1.6.3【必须】外部输入拼接到 HTTP 响应头中需进行过滤</h4><ul><li>应尽量避免外部可控参数拼接到 HTTP 响应头中，如业务需要则需要过滤掉<code>\r</code>、<code>\n</code>等换行符，或者拒绝携带换行符号的外部输入。</li></ul><h4 id="1-6-4【必须】外部输入拼接到-response-页面前进行编码处理"><a href="#1-6-4【必须】外部输入拼接到-response-页面前进行编码处理" class="headerlink" title="1.6.4【必须】外部输入拼接到 response 页面前进行编码处理"></a>1.6.4【必须】外部输入拼接到 response 页面前进行编码处理</h4><ul><li>直出 html 页面或使用模板生成 html 页面的，推荐使用<code>text/template</code>自动编码，或者使用<code>html.EscapeString</code>或<code>text/template</code>对<code>&lt;, &gt;, &amp;, &#39;,&quot;</code>等字符进行编码。</li></ul><pre><code class="go">import (    &quot;html/template&quot;)func outtemplate(w http.ResponseWriter, r *http.Request) &#123;    param1 := r.URL.Query().Get(&quot;param1&quot;)    tmpl := template.New(&quot;hello&quot;)    tmpl, _ = tmpl.Parse(`&#123;&#123;define "T"&#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;end&#125;&#125;`)    tmpl.ExecuteTemplate(w, &quot;T&quot;, param1)&#125;</code></pre><p><a id="2.1.7"></a></p><h3 id="1-7-会话管理"><a href="#1-7-会话管理" class="headerlink" title="1.7 会话管理"></a>1.7 会话管理</h3><h4 id="1-7-1【必须】安全维护-session-信息"><a href="#1-7-1【必须】安全维护-session-信息" class="headerlink" title="1.7.1【必须】安全维护 session 信息"></a>1.7.1【必须】安全维护 session 信息</h4><ul><li>用户登录时应重新生成 session，退出登录后应清理 session。</li></ul><pre><code class="go">import (    &quot;github.com/gorilla/handlers&quot;    &quot;github.com/gorilla/mux&quot;    &quot;net/http&quot;)// 创建cookiefunc setToken(res http.ResponseWriter, req *http.Request) &#123;    expireToken := time.Now().Add(time.Minute * 30).Unix()    expireCookie := time.Now().Add(time.Minute * 30)    //...    cookie := http.Cookie&#123;        Name:     &quot;Auth&quot;,        Value:    signedToken,        Expires:  expireCookie, // 过期失效        HttpOnly: true,        Path:     &quot;/&quot;,        Domain:   &quot;127.0.0.1&quot;,        Secure:   true,    &#125;    http.SetCookie(res, &amp;cookie)    http.Redirect(res, req, &quot;/profile&quot;, 307)&#125;// 删除cookiefunc logout(res http.ResponseWriter, req *http.Request) &#123;    deleteCookie := http.Cookie&#123;        Name:    &quot;Auth&quot;,        Value:   &quot;none&quot;,        Expires: time.Now(),    &#125;    http.SetCookie(res, &amp;deleteCookie)    return&#125;</code></pre><h4 id="1-7-2【必须】CSRF-防护"><a href="#1-7-2【必须】CSRF-防护" class="headerlink" title="1.7.2【必须】CSRF 防护"></a>1.7.2【必须】CSRF 防护</h4><ul><li>涉及系统敏感操作或可读取敏感信息的接口应校验<code>Referer</code>或添加<code>csrf_token</code>。</li></ul><pre><code class="go">// goodimport (    &quot;github.com/gorilla/csrf&quot;    &quot;github.com/gorilla/mux&quot;    &quot;net/http&quot;)func main() &#123;    r := mux.NewRouter()    r.HandleFunc(&quot;/signup&quot;, ShowSignupForm)    r.HandleFunc(&quot;/signup/post&quot;, SubmitSignupForm)    // 使用csrf_token验证    http.ListenAndServe(&quot;:8000&quot;,        csrf.Protect([]byte(&quot;32-byte-long-auth-key&quot;))(r))&#125;</code></pre><p><a id="2.1.8"></a></p><h3 id="1-8-访问控制"><a href="#1-8-访问控制" class="headerlink" title="1.8 访问控制"></a>1.8 访问控制</h3><h4 id="1-8-1【必须】默认鉴权"><a href="#1-8-1【必须】默认鉴权" class="headerlink" title="1.8.1【必须】默认鉴权"></a>1.8.1【必须】默认鉴权</h4><ul><li><p>除非资源完全可对外开放，否则系统默认进行身份认证，使用白名单的方式放开不需要认证的接口或页面。</p></li><li><p>根据资源的机密程度和用户角色，以最小权限原则，设置不同级别的权限，如完全公开、登录可读、登录可写、特定用户可读、特定用户可写等</p></li><li><p>涉及用户自身相关的数据的读写必须验证登录态用户身份及其权限，避免越权操作</p><pre><code class="sql">-- 伪代码select id from table where id=:id and userid=session.userid</code></pre></li><li><p>没有独立账号体系的外网服务使用<code>QQ</code>或<code>微信</code>登录，内网服务使用<code>统一登录服务</code>登录，其他使用账号密码登录的服务需要增加验证码等二次验证</p></li></ul><p><a id="2.1.9"></a></p><h3 id="1-9-并发保护"><a href="#1-9-并发保护" class="headerlink" title="1.9 并发保护"></a>1.9 并发保护</h3><h4 id="1-9-1【必须】禁止在闭包中直接调用循环变量"><a href="#1-9-1【必须】禁止在闭包中直接调用循环变量" class="headerlink" title="1.9.1【必须】禁止在闭包中直接调用循环变量"></a>1.9.1【必须】禁止在闭包中直接调用循环变量</h4><ul><li>在循环中启动协程，当协程中使用到了循环的索引值，由于多个协程同时使用同一个变量会产生数据竞争，造成执行结果异常。</li></ul><pre><code class="go">// badfunc main() &#123;    runtime.GOMAXPROCS(runtime.NumCPU())    var group sync.WaitGroup    for i := 0; i &lt; 5; i++ &#123;        group.Add(1)        go func() &#123;            defer group.Done()            fmt.Printf(&quot;%-2d&quot;, i) // 这里打印的i不是所期望的        &#125;()    &#125;    group.Wait()&#125;// goodfunc main() &#123;    runtime.GOMAXPROCS(runtime.NumCPU())    var group sync.WaitGroup    for i := 0; i &lt; 5; i++ &#123;        group.Add(1)        go func(j int) &#123;            defer func() &#123;                if r := recover(); r != nil &#123;                    fmt.Println(&quot;Recovered in start()&quot;)                &#125;                group.Done()            &#125;()            fmt.Printf(&quot;%-2d&quot;, j) // 闭包内部使用局部变量        &#125;(i) // 把循环变量显式地传给协程    &#125;    group.Wait()&#125;</code></pre><h4 id="1-9-2【必须】禁止并发写-map"><a href="#1-9-2【必须】禁止并发写-map" class="headerlink" title="1.9.2【必须】禁止并发写 map"></a>1.9.2【必须】禁止并发写 map</h4><ul><li>并发写 map 容易造成程序崩溃并异常退出，建议加锁保护</li></ul><pre><code class="go">// badfunc main() &#123;    m := make(map[int]int)    // 并发读写    go func() &#123;        for &#123;            _ = m[1]        &#125;    &#125;()    go func() &#123;        for &#123;            m[2] = 1        &#125;    &#125;()    select &#123;&#125;&#125;</code></pre><h4 id="1-9-3【必须】确保并发安全"><a href="#1-9-3【必须】确保并发安全" class="headerlink" title="1.9.3【必须】确保并发安全"></a>1.9.3【必须】确保并发安全</h4><p>敏感操作如果未作并发安全限制，可导致数据读写异常，造成业务逻辑限制被绕过。可通过同步锁或者原子操作进行防护。</p><p>通过同步锁共享内存</p><pre><code class="go">// goodvar count intfunc Count(lock *sync.Mutex) &#123;    lock.Lock() // 加写锁    count++    fmt.Println(count)    lock.Unlock() // 解写锁，任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()&#125;func main() &#123;    lock := &amp;sync.Mutex&#123;&#125;    for i := 0; i &lt; 10; i++ &#123;        go Count(lock) // 传递指针是为了防止函数内的锁和调用锁不一致    &#125;    for &#123;        lock.Lock()        c := count        lock.Unlock()        runtime.Gosched() // 交出时间片给协程        if c &gt; 10 &#123;            break        &#125;    &#125;&#125;</code></pre><ul><li>使用<code>sync/atomic</code>执行原子操作</li></ul><pre><code class="go">// goodimport (    &quot;sync&quot;    &quot;sync/atomic&quot;)func main() &#123;    type Map map[string]string    var m atomic.Value    m.Store(make(Map))    var mu sync.Mutex // used only by writers    read := func(key string) (val string) &#123;        m1 := m.Load().(Map)        return m1[key]    &#125;    insert := func(key, val string) &#123;        mu.Lock() // 与潜在写入同步        defer mu.Unlock()        m1 := m.Load().(Map) // 导入struct当前数据        m2 := make(Map)      // 创建新值        for k, v := range m1 &#123;            m2[k] = v        &#125;        m2[key] = val        m.Store(m2) // 用新的替代当前对象    &#125;    _, _ = read, insert&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 安全指南 </tag>
            
            <tag> Tencent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/26/hello-world/"/>
      <url>/2021/06/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> 2222 </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2021/06/23/test/"/>
      <url>/2021/06/23/test/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言笔记面试题（基础语法）"><a href="#Go语言笔记面试题（基础语法）" class="headerlink" title="Go语言笔记面试题（基础语法）"></a>Go语言笔记面试题（基础语法）</h2><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p><strong>Q1 = 和 ：= 的区别？</strong></p><blockquote><p>:=  声明 + 赋值</p><p>= 仅赋值</p><p>var foo int </p><p>foot = 10 </p><p>等价于</p><p>foo := 10</p></blockquote><p><strong>Q2 指针的作用</strong></p><blockquote><p>指针用来保存变量的地址</p><pre><code class="go">var x = 5var p *int = &amp;x</code></pre><ul><li>*运算符，也称解引运算符，用于访问地址中的值</li><li>&amp;运算符，也称地址运算符，用于返回变量的地址</li></ul></blockquote><p><strong>Q3 Go允许多个返回值吗？</strong></p><blockquote><p>允许</p><pre><code class="go">func swap(x, y string) (string, string) &#123;   return y, x&#125;</code></pre></blockquote><p><strong>Q4 Go 有异常类型吗</strong></p><blockquote><p>Go没有异常类型，只有错误类型（Error），通常用返回值来表示异常状态</p><pre><code class="go">f,err = os.Open(&quot;text.txt&quot;)if err != nil &#123;    log.Fatal(err)&#125;</code></pre></blockquote><p><strong>Q5 什么是协程（Goroutine）</strong></p><blockquote><p>Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p></blockquote><p><strong>Q6 如何高效地拼接字符串</strong></p><blockquote><p>Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用 <code>strings.Builder</code>，最小化内存拷贝次数。</p></blockquote><p><strong>Q7 什么是 rune 类型</strong></p><blockquote><p>ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。</p></blockquote><p><strong>Q8 如何判断 map 中是否包含某个 key ？</strong></p><blockquote><pre><code class="go">if val, ok := dict[&quot;foo&quot;]; ok &#123;    //do something here&#125;</code></pre><p><code>dict[&quot;foo&quot;]</code> 有 2 个返回值，val 和 ok，如果 ok 等于 <code>true</code>，则说明 dict 包含 key <code>&quot;foo&quot;</code>，val 将被赋予 <code>&quot;foo&quot;</code> 对应的值。</p></blockquote><p><strong>Q9 Go 支持默认参数或可选参数吗？</strong></p><blockquote><p>Go 语言不支持可选参数（python 支持），也不支持方法重载</p></blockquote><p><strong>Q10 defer 的执行顺序</strong></p><blockquote><ul><li>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。</li><li>defer 在 return 语句之后执行，但在函数退出之前，defer 可以修改返回值。</li></ul><pre><code class="go">func test() int &#123;    i := 0    defer func() &#123;        fmt.Println(&quot;defer1&quot;)    &#125;()    defer func() &#123;        i += 1        fmt.Println(&quot;defer2&quot;)    &#125;()    return i&#125;func main() &#123;    fmt.Println(&quot;return&quot;, test())&#125;</code></pre><p>可以看到 defer 的执行顺序：后进先出。但是返回值并没有被修改，这是由于 Go 的返回机制决定的，执行 return 语句后，Go 会创建一个临时变量保存返回值，因此，defer 语句修改了局部变量 i，并没有修改返回值。</p></blockquote><p><strong>Q11 如何交换 2 个变量的值？</strong></p><blockquote><pre><code class="go">a,b := &quot;a&quot;,&quot;b&quot;a,b = b,a</code></pre></blockquote><p><strong>Q12 Go 语言 tag 的用处？</strong></p><blockquote><p>tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。</p><pre><code class="go">type Stu struct &#123;    Name string `json:&quot;stu_name&quot;`    ID   string `json:&quot;stu_id&quot;`    Age  int    `json:&quot;-&quot;`&#125;</code></pre><p>tag 定义了结构体字段与 json 字段的转换关系，Name -&gt; <code>stu_name</code>, ID -&gt; <code>stu_id</code>，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换</p></blockquote><p><strong>Q13字符串打印时，<code>%v</code> 和 <code>%+v</code> 的区别</strong></p><blockquote><p><code>%v</code> 和 <code>%+v</code> 都可以用来打印 struct 的值，区别在于 <code>%v</code> 仅打印各个字段的值，<code>%+v</code> 还会打印各个字段的名称。</p><pre><code class="go">type Stu struct &#123;    Name string&#125;func main() &#123;    fmt.Printf(&quot;%v\n&quot;, Stu&#123;&quot;Tom&quot;&#125;) // &#123;Tom&#125;    fmt.Printf(&quot;%+v\n&quot;, Stu&#123;&quot;Tom&quot;&#125;) // &#123;Name:Tom&#125;&#125;</code></pre></blockquote><p><strong>Q14 Go 语言中如何表示枚举值(enums)</strong></p><blockquote><pre><code class="go">type StuType int32const (    Type1 StuType = iota    Type2    Type3    Type4)func main() &#123;    fmt.Println(Type1, Type2, Type3, Type4) // 0, 1, 2, 3&#125;</code></pre><p>通常使用常量（const）来表示枚举</p></blockquote><p><strong>Q15 空 struct{} 的用途</strong></p><blockquote><ul><li><p>使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值</p></li><li><p>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。</p></li><li><p>使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</p></li><li><p>再比如，声明只包含方法的结构体。</p></li></ul></blockquote><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><strong>Q1 init() 函数是什么时候执行的</strong></p><blockquote><p><code>init()</code> 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</p><p>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 <code>init()</code> 函数。同一个包，甚至是同一个源文件可以有多个 <code>init()</code> 函数。<code>init()</code> 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 <code>init()</code> 函数的执行顺序不作保证。</p><p>一句话总结： import –&gt; const –&gt; var –&gt; <code>init()</code> –&gt; <code>main()</code></p></blockquote><p><strong>Q2 Go 语言的局部变量分配在栈上还是堆上</strong></p><blockquote><p>由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的<strong>作用域没有超出函数范围</strong>，就可以在栈上，反之则必须分配在堆上。</p><pre><code class="go">func foo() *int &#123;    v := 11    return &amp;v&#125;func main() &#123;    m := foo()    println(*m) // 11&#125;</code></pre><p><code>foo()</code> 函数中，如果 v 分配在栈上，foo 函数返回时，<code>&amp;v</code> 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值</p></blockquote><p><strong>Q3 2 个 interface 可以比较吗</strong></p><blockquote><p>Go 语言中，interface 的内部实现包含了 2 个字段，类型 <code>T</code> 和 值 <code>V</code>，interface 可以使用 <code>==</code> 或 <code>!=</code> 比较。2 个 interface 相等有以下 2 种情况</p><p>1、两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）</p><p>2、类型 V 相同，且对应的值 V 相等。</p><pre><code class="go">type Stu struct &#123;    Name string&#125;type StuInt interface&#123;&#125;func main() &#123;    var stu1, stu2 StuInt = &amp;Stu&#123;&quot;Tom&quot;&#125;, &amp;Stu&#123;&quot;Tom&quot;&#125;    var stu3, stu4 StuInt = Stu&#123;&quot;Tom&quot;&#125;, Stu&#123;&quot;Tom&quot;&#125;    fmt.Println(stu1 == stu2) // false    fmt.Println(stu3 == stu4) // true&#125;</code></pre><p><code>stu1</code> 和 <code>stu2</code> 对应的类型是 <code>*Stu</code>，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。<br><code>stu3</code> 和 <code>stu3</code> 对应的类型是 <code>Stu</code>，值是 Stu 结构体，且各字段相等，因此结果为 true。</p></blockquote><p><strong>Q4 两个 nil 可能不相等吗？</strong></p><blockquote><p>可能</p><p>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 <code>T</code> 和 值 <code>V</code>。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。</p><pre><code class="go">func main() &#123;    var p *int = nil    var i interface&#123;&#125; = p    fmt.Println(i == p) // true    fmt.Println(p == nil) // true    fmt.Println(i == nil) // false&#125;</code></pre><p>这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为<code>(T=*int, V=nil)</code>，i 与 p 作比较时，将 p 转换为接口后再比较，因此 <code>i == p</code>，p 与 nil 比较，直接比较值，所以 <code>p == nil</code>。</p><p>但是当 i 与 nil 比较时，会将 nil 转换为接口 <code>(T=nil, V=nil)</code>，与i <code>(T=*int, V=nil)</code> 不相等，因此 <code>i != nil</code>。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil</p></blockquote><p><strong>Q5 简述 Go 语言GC(垃圾回收)的工作原理</strong></p><blockquote><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。<br>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象。</li><li>灰色：存活对象，子对象待处理。</li><li>黑色：存活对象</li></ul><p>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><pre><code>A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)</code></pre><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><pre><code>A (黑) -&gt; B (灰) -&gt; C (白)   ↓ D (白)</code></pre><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)</li><li>2）使用三色标记法标记（Marking, 并发）</li><li>3）标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>4）清理(Sweeping, 并发)</li></ul></blockquote><p><strong>Q6 函数返回局部变量的指针是否安全</strong></p><blockquote><p>这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。</p></blockquote><p><strong>Q7 非接口非接口的任意类型 T() 都能够调用 <code>*T</code> 的方法吗？反过来呢？</strong></p><blockquote><ul><li>一个T类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型<code>*T</code>声明的方法。</li><li>反过来，一个<code>*T</code>类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型<code>*T</code>自动隐式声明一个同名和同签名的方法。</li></ul><p>哪些值是不可寻址的呢？</p><ul><li>字符串中的字节；</li><li>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；</li><li>常量；</li><li>包级别的函数等。</li></ul><p>举一个例子，定义类型 T，并为类型 <code>*T</code> 声明一个方法 <code>hello()</code>，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</p><pre><code class="go">type T stringfunc (t *T) hello() &#123;    fmt.Println(&quot;hello&quot;)&#125;func main() &#123;    var t1 T = &quot;ABC&quot;    t1.hello() // hello    const t2 T = &quot;ABC&quot;    t2.hello() // error: cannot call pointer method on t&#125;</code></pre></blockquote><hr><h4 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h4><p><strong>Q1 无缓冲的 channel 和 有缓冲的 channel 的区别</strong></p><blockquote><p>对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。</p><p>对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。</p><pre><code class="go">func main() &#123;    st := time.Now()    ch := make(chan bool)    go func ()  &#123;        time.Sleep(time.Second * 2)        &lt;-ch    &#125;()    ch &lt;- true  // 无缓冲，发送方阻塞直到接收方接收到数据。    fmt.Printf(&quot;cost %.1f s\n&quot;, time.Now().Sub(st).Seconds())    time.Sleep(time.Second * 5)&#125;</code></pre><pre><code class="go">func main() &#123;    st := time.Now()    ch := make(chan bool, 2)    go func ()  &#123;        time.Sleep(time.Second * 2)        &lt;-ch    &#125;()    ch &lt;- true    ch &lt;- true // 缓冲区为 2，发送方不阻塞，继续往下执行    fmt.Printf(&quot;cost %.1f s\n&quot;, time.Now().Sub(st).Seconds()) // cost 0.0 s    ch &lt;- true // 缓冲区使用完，发送方阻塞，2s 后接收方接收到数据，释放一个插槽，继续往下执行    fmt.Printf(&quot;cost %.1f s\n&quot;, time.Now().Sub(st).Seconds()) // cost 2.0 s    time.Sleep(time.Second * 5)</code></pre></blockquote><p><strong>Q2 什么是协程泄露(Goroutine Leak)</strong></p><blockquote><p>协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：</p><ul><li><p>缺少接收器，导致发送阻塞</p><p>每执行一次 query，则启动1000个协程向信道 ch 发送数字 0，但只接收了一次，导致 999 个协程被阻塞</p></li></ul><pre><code class="go">func query() int &#123;    ch := make(chan int)    for i := 0; i &lt; 1000; i++ &#123;        go func() &#123; ch &lt;- 0 &#125;()    &#125;    return &lt;-ch&#125;func main() &#123;    for i := 0; i &lt; 4; i++ &#123;        query()        fmt.Printf(&quot;goroutines: %d\n&quot;, runtime.NumGoroutine())    &#125;&#125;</code></pre><ul><li><p>缺少发送器，导致接收阻塞</p><p>启动 1000 个协程接收信道的信息，但信道并不会发送那么多次的信息，也会导致接收协程被阻塞，不能退出。</p></li><li><p>死锁(dead lock)</p><p>两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出</p></li><li><p>无限循环(infinite loops)</p><p>为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏。</p></li></ul><pre><code class="go">func request(url string, wg sync.WaitGroup) &#123;    for &#123;        if _, err := http.Get(url); err == nil &#123;            // write to db            break        &#125;        time.Sleep(time.Second)    &#125;    wg.Done()&#125;func main() &#123;    var wg sync.WaitGroup    for i := 0; i &lt; 1000; i++ &#123;        wg.Add(1)        go request(fmt.Sprintf(&quot;exampe.com/%d&quot;, i), wg)    &#125;    wg.Wait()&#125;</code></pre></blockquote><p><strong>Q3 Go 可以限制运行时操作系统线程的数量吗</strong></p><blockquote><p>可以使用环境变量 <code>GOMAXPROCS</code> 或 <code>runtime.GOMAXPROCS(num int)</code> 设置.</p><pre><code class="go">runtime.GOMAXPROCS(1) // 限制同时执行Go代码的操作系统线程数为 1</code></pre><p>从官方文档的解释可以看到，<code>GOMAXPROCS</code> 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。<code>GOMAXPROCS</code> 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。</p></blockquote><hr><h4 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h4><p><strong>常量与变量</strong></p><blockquote><pre><code class="go">func main() &#123;    const (        a, b = &quot;golang&quot;, 100        d, e     //等价于 a, b = &quot;golang&quot;, 100        f bool = true        g        //等价于 f bool = true    )    fmt.Println(d, e, g)&#125;</code></pre><p>在同一个 const group 中，如果常量定义与前一行的定义一致，则可以省略类型和值。编译时，会按照前一行的定义自动补全。即等价于</p></blockquote><blockquote><pre><code class="go">func main() &#123;    const N = 100    var x int = N    const M int32 = 100       var y int = M    //cannot use M (type int32) as type int in assignment    fmt.Println(x, y)&#125;</code></pre><p>Go 语言中，常量分为无类型常量和有类型常量两种，<code>const N = 100</code>，属于无类型常量，赋值给其他变量时，如果字面量能够转换为对应类型的变量，则赋值成功，例如，<code>var x int = N</code>。但是对于有类型的常量 <code>const M int32 = 100</code>，赋值给其他变量时，需要类型匹配才能成功，所以显示地类型转换：</p><pre><code class="go">var y int = int(M)</code></pre></blockquote><blockquote><pre><code class="go">func main() &#123;    var a int8 = -1    var b int8 = -128 / a    fmt.Println(b)&#125;</code></pre><p>int8 能表示的数字的范围是 [-2^7, 2^7-1]，即 [-128, 127]。-128 是无类型常量，转换为 int8，再除以变量 -1，结果为 128，常量除以变量，结果是一个变量。变量转换时允许溢出，符号位变为1，转为补码后恰好等于 -128。</p></blockquote><blockquote><pre><code class="go">func main() &#123;    const a int8 = -1    var b int8 = -128 / a    fmt.Println(b)&#125;</code></pre><p>编译失败：constant 128 overflows int8</p><p>-128 和 a 都是常量，在编译时求值，-128 / a = 128，两个常量相除，结果也是一个常量，常量类型转换时不允许溢出，因而编译失败。</p></blockquote><p><strong>作用域</strong></p><blockquote><pre><code class="go">func main() &#123;    var err error    if err == nil &#123;        err := fmt.Errorf(&quot;err&quot;)        fmt.Println(1, err)    &#125;    if err != nil &#123;        fmt.Println(2, err)    &#125;&#125;</code></pre><p><code>:=</code> 表示声明并赋值，<code>=</code> 表示仅赋值。</p><p>变量的作用域是大括号，因此在第一个 if 语句 <code>if err == nil</code> 内部重新声明且赋值了与外部变量同名的局部变量 err。对该局部变量的赋值不会影响到外部的 err。因此第二个 if 语句 <code>if err != nil</code> 不成立。所以只打印了 <code>1 err</code></p></blockquote><p><strong>defer 延迟调用</strong></p><blockquote><pre><code class="go">type T struct&#123;&#125;func (t T) f(n int) T &#123;    fmt.Print(n)    return t&#125;func main() &#123;    var t T    defer t.f(1).f(2)    fmt.Print(3)&#125;</code></pre><p>defer 延迟调用时，需要保存函数指针和参数，因此<strong>链式调用的情况下</strong>，除了最后一个函数/方法外的函数/方法都会在调用时直接执行。也就是说 <code>t.f(1)</code> 直接执行，然后执行 <code>fmt.Print(3)</code>，最后函数返回时再执行 <code>.f(2)</code>，因此输出是 132。</p></blockquote><blockquote><pre><code class="go">func f(n int) &#123;    defer fmt.Println(n)    n += 100&#125;func main() &#123;    f(1)&#125;</code></pre><p>打印 1 而不是 101。defer 语句执行时，会将需要延迟调用的函数和参数保存起来，也就是说，执行到 defer 时，参数 n(此时等于1) 已经被保存了。因此后面对 n 的改动并不会影响延迟函数调用的结果</p></blockquote><blockquote><pre><code class="go">func main() &#123;    n := 1    defer func() &#123;        fmt.Println(n)    &#125;()    n += 100&#125;</code></pre><p>匿名函数没有通过传参的方式将 n 传入，因此匿名函数内的 n 和函数外部的 n 是同一个，延迟执行时，已经被改变为 101。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
