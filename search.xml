<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2021/06/23/test/"/>
      <url>/2021/06/23/test/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言笔记面试题（基础语法）"><a href="#Go语言笔记面试题（基础语法）" class="headerlink" title="Go语言笔记面试题（基础语法）"></a>Go语言笔记面试题（基础语法）</h2><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p><strong>Q1 = 和 ：= 的区别？</strong></p><blockquote><p>:=  声明 + 赋值</p><p>= 仅赋值</p><p>var foo int </p><p>foot = 10 </p><p>等价于</p><p>foo := 10</p></blockquote><p><strong>Q2 指针的作用</strong></p><blockquote><p>指针用来保存变量的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;x</span><br></pre></td></tr></table></figure><ul><li>*运算符，也称解引运算符，用于访问地址中的值</li><li>&amp;运算符，也称地址运算符，用于返回变量的地址</li></ul></blockquote><p><strong>Q3 Go允许多个返回值吗？</strong></p><blockquote><p>允许</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>Q4 Go 有异常类型吗</strong></p><blockquote><p>Go没有异常类型，只有错误类型（Error），通常用返回值来表示异常状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f,err = os.Open(<span class="string">&quot;text.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>Q5 什么是协程（Goroutine）</strong></p><blockquote><p>Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p></blockquote><p><strong>Q6 如何高效地拼接字符串</strong></p><blockquote><p>Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用 <code>strings.Builder</code>，最小化内存拷贝次数。</p></blockquote><p><strong>Q7 什么是 rune 类型</strong></p><blockquote><p>ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。</p></blockquote><p><strong>Q8 如何判断 map 中是否包含某个 key ？</strong></p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> val, ok := dict[<span class="string">&quot;foo&quot;</span>]; ok &#123;</span><br><span class="line">    <span class="comment">//do something here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dict[&quot;foo&quot;]</code> 有 2 个返回值，val 和 ok，如果 ok 等于 <code>true</code>，则说明 dict 包含 key <code>&quot;foo&quot;</code>，val 将被赋予 <code>&quot;foo&quot;</code> 对应的值。</p></blockquote><p><strong>Q9 Go 支持默认参数或可选参数吗？</strong></p><blockquote><p>Go 语言不支持可选参数（python 支持），也不支持方法重载</p></blockquote><p><strong>Q10 defer 的执行顺序</strong></p><blockquote><ul><li>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。</li><li>defer 在 return 语句之后执行，但在函数退出之前，defer 可以修改返回值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;return&quot;</span>, test())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 defer 的执行顺序：后进先出。但是返回值并没有被修改，这是由于 Go 的返回机制决定的，执行 return 语句后，Go 会创建一个临时变量保存返回值，因此，defer 语句修改了局部变量 i，并没有修改返回值。</p></blockquote><p><strong>Q11 如何交换 2 个变量的值？</strong></p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a,b := <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span></span><br><span class="line">a,b = b,a</span><br></pre></td></tr></table></figure></blockquote><p><strong>Q12 Go 语言 tag 的用处？</strong></p><blockquote><p>tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:&quot;stu_name&quot;`</span></span><br><span class="line">ID   <span class="keyword">string</span> <span class="string">`json:&quot;stu_id&quot;`</span></span><br><span class="line">Age  <span class="keyword">int</span>    <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tag 定义了结构体字段与 json 字段的转换关系，Name -&gt; <code>stu_name</code>, ID -&gt; <code>stu_id</code>，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换</p></blockquote><p><strong>Q13字符串打印时，<code>%v</code> 和 <code>%+v</code> 的区别</strong></p><blockquote><p><code>%v</code> 和 <code>%+v</code> 都可以用来打印 struct 的值，区别在于 <code>%v</code> 仅打印各个字段的值，<code>%+v</code> 还会打印各个字段的名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;) <span class="comment">// &#123;Tom&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;) <span class="comment">// &#123;Name:Tom&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>Q14 Go 语言中如何表示枚举值(enums)</strong></p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StuType <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Type1 StuType = <span class="literal">iota</span></span><br><span class="line">Type2</span><br><span class="line">Type3</span><br><span class="line">Type4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Type1, Type2, Type3, Type4) <span class="comment">// 0, 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常使用常量（const）来表示枚举</p></blockquote><p><strong>Q15 空 struct{} 的用途</strong></p><blockquote><ul><li><p>使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值</p></li><li><p>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。</p></li><li><p>使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</p></li><li><p>再比如，声明只包含方法的结构体。</p></li></ul></blockquote><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><strong>Q1 init() 函数是什么时候执行的</strong></p><blockquote><p><code>init()</code> 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</p><p>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 <code>init()</code> 函数。同一个包，甚至是同一个源文件可以有多个 <code>init()</code> 函数。<code>init()</code> 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 <code>init()</code> 函数的执行顺序不作保证。</p><p>一句话总结： import –&gt; const –&gt; var –&gt; <code>init()</code> –&gt; <code>main()</code></p></blockquote><p><strong>Q2 Go 语言的局部变量分配在栈上还是堆上</strong></p><blockquote><p>由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的<strong>作用域没有超出函数范围</strong>，就可以在栈上，反之则必须分配在堆上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">v := <span class="number">11</span></span><br><span class="line"><span class="keyword">return</span> &amp;v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := foo()</span><br><span class="line"><span class="built_in">println</span>(*m) <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>foo()</code> 函数中，如果 v 分配在栈上，foo 函数返回时，<code>&amp;v</code> 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值</p></blockquote><p><strong>Q3 2 个 interface 可以比较吗</strong></p><blockquote><p>Go 语言中，interface 的内部实现包含了 2 个字段，类型 <code>T</code> 和 值 <code>V</code>，interface 可以使用 <code>==</code> 或 <code>!=</code> 比较。2 个 interface 相等有以下 2 种情况</p><p>1、两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）</p><p>2、类型 V 相同，且对应的值 V 相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StuInt <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> stu1, stu2 StuInt = &amp;Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;, &amp;Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> stu3, stu4 StuInt = Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;, Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">fmt.Println(stu1 == stu2) <span class="comment">// false</span></span><br><span class="line">fmt.Println(stu3 == stu4) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stu1</code> 和 <code>stu2</code> 对应的类型是 <code>*Stu</code>，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。<br><code>stu3</code> 和 <code>stu3</code> 对应的类型是 <code>Stu</code>，值是 Stu 结构体，且各字段相等，因此结果为 true。</p></blockquote><p><strong>Q4 两个 nil 可能不相等吗？</strong></p><blockquote><p>可能</p><p>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 <code>T</code> 和 值 <code>V</code>。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = p</span><br><span class="line">fmt.Println(i == p) <span class="comment">// true</span></span><br><span class="line">fmt.Println(p == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">fmt.Println(i == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为<code>(T=*int, V=nil)</code>，i 与 p 作比较时，将 p 转换为接口后再比较，因此 <code>i == p</code>，p 与 nil 比较，直接比较值，所以 <code>p == nil</code>。</p><p>但是当 i 与 nil 比较时，会将 nil 转换为接口 <code>(T=nil, V=nil)</code>，与i <code>(T=*int, V=nil)</code> 不相等，因此 <code>i != nil</code>。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil</p></blockquote><p><strong>Q5 简述 Go 语言GC(垃圾回收)的工作原理</strong></p><blockquote><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。<br>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象。</li><li>灰色：存活对象，子对象待处理。</li><li>黑色：存活对象</li></ul><p>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)</span><br></pre></td></tr></table></figure><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白) </span><br><span class="line">  ↓</span><br><span class="line"> D (白)</span><br></pre></td></tr></table></figure><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)</li><li>2）使用三色标记法标记（Marking, 并发）</li><li>3）标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>4）清理(Sweeping, 并发)</li></ul></blockquote><p><strong>Q6 函数返回局部变量的指针是否安全</strong></p><blockquote><p>这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。</p></blockquote><p><strong>Q7 非接口非接口的任意类型 T() 都能够调用 <code>*T</code> 的方法吗？反过来呢？</strong></p><blockquote><ul><li>一个T类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型<code>*T</code>声明的方法。</li><li>反过来，一个<code>*T</code>类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型<code>*T</code>自动隐式声明一个同名和同签名的方法。</li></ul><p>哪些值是不可寻址的呢？</p><ul><li>字符串中的字节；</li><li>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；</li><li>常量；</li><li>包级别的函数等。</li></ul><p>举一个例子，定义类型 T，并为类型 <code>*T</code> 声明一个方法 <code>hello()</code>，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t1 T = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">t1.hello() <span class="comment">// hello</span></span><br><span class="line"><span class="keyword">const</span> t2 T = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">t2.hello() <span class="comment">// error: cannot call pointer method on t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h4><p><strong>Q1 无缓冲的 channel 和 有缓冲的 channel 的区别</strong></p><blockquote><p>对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。</p><p>对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">st := time.Now()</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;()</span><br><span class="line">ch &lt;- <span class="literal">true</span>  <span class="comment">// 无缓冲，发送方阻塞直到接收方接收到数据。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;cost %.1f s\n&quot;</span>, time.Now().Sub(st).Seconds())</span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">st := time.Now()</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;()</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">ch &lt;- <span class="literal">true</span> <span class="comment">// 缓冲区为 2，发送方不阻塞，继续往下执行</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;cost %.1f s\n&quot;</span>, time.Now().Sub(st).Seconds()) <span class="comment">// cost 0.0 s</span></span><br><span class="line">ch &lt;- <span class="literal">true</span> <span class="comment">// 缓冲区使用完，发送方阻塞，2s 后接收方接收到数据，释放一个插槽，继续往下执行</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;cost %.1f s\n&quot;</span>, time.Now().Sub(st).Seconds()) <span class="comment">// cost 2.0 s</span></span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br></pre></td></tr></table></figure></blockquote><p><strong>Q2 什么是协程泄露(Goroutine Leak)</strong></p><blockquote><p>协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：</p><ul><li><p>缺少接收器，导致发送阻塞</p><p>每执行一次 query，则启动1000个协程向信道 ch 发送数字 0，但只接收了一次，导致 999 个协程被阻塞</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="number">0</span> &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">query()</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutines: %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>缺少发送器，导致接收阻塞</p><p>启动 1000 个协程接收信道的信息，但信道并不会发送那么多次的信息，也会导致接收协程被阻塞，不能退出。</p></li><li><p>死锁(dead lock)</p><p>两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出</p></li><li><p>无限循环(infinite loops)</p><p>为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(url <span class="keyword">string</span>, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := http.Get(url); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// write to db</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> request(fmt.Sprintf(<span class="string">&quot;exampe.com/%d&quot;</span>, i), wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>Q3 Go 可以限制运行时操作系统线程的数量吗</strong></p><blockquote><p>可以使用环境变量 <code>GOMAXPROCS</code> 或 <code>runtime.GOMAXPROCS(num int)</code> 设置.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>) <span class="comment">// 限制同时执行Go代码的操作系统线程数为 1</span></span><br></pre></td></tr></table></figure><p>从官方文档的解释可以看到，<code>GOMAXPROCS</code> 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。<code>GOMAXPROCS</code> 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。</p></blockquote><hr><h4 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h4><p><strong>常量与变量</strong></p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="string">&quot;golang&quot;</span>, <span class="number">100</span></span><br><span class="line">d, e     <span class="comment">//等价于 a, b = &quot;golang&quot;, 100</span></span><br><span class="line">f <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">g    <span class="comment">//等价于 f bool = true</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(d, e, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个 const group 中，如果常量定义与前一行的定义一致，则可以省略类型和值。编译时，会按照前一行的定义自动补全。即等价于</p></blockquote><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> N = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span> = N</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> M <span class="keyword">int32</span> = <span class="number">100</span>   </span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">int</span> = M    <span class="comment">//cannot use M (type int32) as type int in assignment</span></span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言中，常量分为无类型常量和有类型常量两种，<code>const N = 100</code>，属于无类型常量，赋值给其他变量时，如果字面量能够转换为对应类型的变量，则赋值成功，例如，<code>var x int = N</code>。但是对于有类型的常量 <code>const M int32 = 100</code>，赋值给其他变量时，需要类型匹配才能成功，所以显示地类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y <span class="keyword">int</span> = <span class="keyword">int</span>(M)</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int8</span> = <span class="number">-1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int8</span> = <span class="number">-128</span> / a</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int8 能表示的数字的范围是 [-2^7, 2^7-1]，即 [-128, 127]。-128 是无类型常量，转换为 int8，再除以变量 -1，结果为 128，常量除以变量，结果是一个变量。变量转换时允许溢出，符号位变为1，转为补码后恰好等于 -128。</p></blockquote><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> a <span class="keyword">int8</span> = <span class="number">-1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int8</span> = <span class="number">-128</span> / a</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译失败：constant 128 overflows int8</p><p>-128 和 a 都是常量，在编译时求值，-128 / a = 128，两个常量相除，结果也是一个常量，常量类型转换时不允许溢出，因而编译失败。</p></blockquote><p><strong>作用域</strong></p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;err&quot;</span>)</span><br><span class="line">fmt.Println(<span class="number">1</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="number">2</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>:=</code> 表示声明并赋值，<code>=</code> 表示仅赋值。</p><p>变量的作用域是大括号，因此在第一个 if 语句 <code>if err == nil</code> 内部重新声明且赋值了与外部变量同名的局部变量 err。对该局部变量的赋值不会影响到外部的 err。因此第二个 if 语句 <code>if err != nil</code> 不成立。所以只打印了 <code>1 err</code></p></blockquote><p><strong>defer 延迟调用</strong></p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">fmt.Print(n)</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line"><span class="keyword">defer</span> t.f(<span class="number">1</span>).f(<span class="number">2</span>)</span><br><span class="line">fmt.Print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer 延迟调用时，需要保存函数指针和参数，因此<strong>链式调用的情况下</strong>，除了最后一个函数/方法外的函数/方法都会在调用时直接执行。也就是说 <code>t.f(1)</code> 直接执行，然后执行 <code>fmt.Print(3)</code>，最后函数返回时再执行 <code>.f(2)</code>，因此输出是 132。</p></blockquote><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(n)</span><br><span class="line">n += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 1 而不是 101。defer 语句执行时，会将需要延迟调用的函数和参数保存起来，也就是说，执行到 defer 时，参数 n(此时等于1) 已经被保存了。因此后面对 n 的改动并不会影响延迟函数调用的结果</p></blockquote><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">1</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;()</span><br><span class="line">n += <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数没有通过传参的方式将 n 传入，因此匿名函数内的 n 和函数外部的 n 是同一个，延迟执行时，已经被改变为 101。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/23/hello-world/"/>
      <url>/2021/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
