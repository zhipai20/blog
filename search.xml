<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2021/06/23/test/"/>
      <url>/2021/06/23/test/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言笔记面试题（基础语法）"><a href="#Go语言笔记面试题（基础语法）" class="headerlink" title="Go语言笔记面试题（基础语法）"></a>Go语言笔记面试题（基础语法）</h2><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p><strong>Q1 = 和 ：= 的区别？</strong></p><blockquote><p>:=  声明 + 赋值</p><p>= 仅赋值</p><p>var foo int </p><p>foot = 10 </p><p>等价于</p><p>foo := 10</p></blockquote><p><strong>Q2 指针的作用</strong></p><blockquote><p>指针用来保存变量的地址</p><pre><code class="go">var x = 5var p *int = &amp;x</code></pre><ul><li>*运算符，也称解引运算符，用于访问地址中的值</li><li>&amp;运算符，也称地址运算符，用于返回变量的地址</li></ul></blockquote><p><strong>Q3 Go允许多个返回值吗？</strong></p><blockquote><p>允许</p><pre><code class="go">func swap(x, y string) (string, string) &#123;   return y, x&#125;</code></pre></blockquote><p><strong>Q4 Go 有异常类型吗</strong></p><blockquote><p>Go没有异常类型，只有错误类型（Error），通常用返回值来表示异常状态</p><pre><code class="go">f,err = os.Open(&quot;text.txt&quot;)if err != nil &#123;    log.Fatal(err)&#125;</code></pre></blockquote><p><strong>Q5 什么是协程（Goroutine）</strong></p><blockquote><p>Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p></blockquote><p><strong>Q6 如何高效地拼接字符串</strong></p><blockquote><p>Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用 <code>strings.Builder</code>，最小化内存拷贝次数。</p></blockquote><p><strong>Q7 什么是 rune 类型</strong></p><blockquote><p>ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。</p></blockquote><p><strong>Q8 如何判断 map 中是否包含某个 key ？</strong></p><blockquote><pre><code class="go">if val, ok := dict[&quot;foo&quot;]; ok &#123;    //do something here&#125;</code></pre><p><code>dict[&quot;foo&quot;]</code> 有 2 个返回值，val 和 ok，如果 ok 等于 <code>true</code>，则说明 dict 包含 key <code>&quot;foo&quot;</code>，val 将被赋予 <code>&quot;foo&quot;</code> 对应的值。</p></blockquote><p><strong>Q9 Go 支持默认参数或可选参数吗？</strong></p><blockquote><p>Go 语言不支持可选参数（python 支持），也不支持方法重载</p></blockquote><p><strong>Q10 defer 的执行顺序</strong></p><blockquote><ul><li>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。</li><li>defer 在 return 语句之后执行，但在函数退出之前，defer 可以修改返回值。</li></ul><pre><code class="go">func test() int &#123;    i := 0    defer func() &#123;        fmt.Println(&quot;defer1&quot;)    &#125;()    defer func() &#123;        i += 1        fmt.Println(&quot;defer2&quot;)    &#125;()    return i&#125;func main() &#123;    fmt.Println(&quot;return&quot;, test())&#125;</code></pre><p>可以看到 defer 的执行顺序：后进先出。但是返回值并没有被修改，这是由于 Go 的返回机制决定的，执行 return 语句后，Go 会创建一个临时变量保存返回值，因此，defer 语句修改了局部变量 i，并没有修改返回值。</p></blockquote><p><strong>Q11 如何交换 2 个变量的值？</strong></p><blockquote><pre><code class="go">a,b := &quot;a&quot;,&quot;b&quot;a,b = b,a</code></pre></blockquote><p><strong>Q12 Go 语言 tag 的用处？</strong></p><blockquote><p>tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。</p><pre><code class="go">type Stu struct &#123;    Name string `json:&quot;stu_name&quot;`    ID   string `json:&quot;stu_id&quot;`    Age  int    `json:&quot;-&quot;`&#125;</code></pre><p>tag 定义了结构体字段与 json 字段的转换关系，Name -&gt; <code>stu_name</code>, ID -&gt; <code>stu_id</code>，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换</p></blockquote><p><strong>Q13字符串打印时，<code>%v</code> 和 <code>%+v</code> 的区别</strong></p><blockquote><p><code>%v</code> 和 <code>%+v</code> 都可以用来打印 struct 的值，区别在于 <code>%v</code> 仅打印各个字段的值，<code>%+v</code> 还会打印各个字段的名称。</p><pre><code class="go">type Stu struct &#123;    Name string&#125;func main() &#123;    fmt.Printf(&quot;%v\n&quot;, Stu&#123;&quot;Tom&quot;&#125;) // &#123;Tom&#125;    fmt.Printf(&quot;%+v\n&quot;, Stu&#123;&quot;Tom&quot;&#125;) // &#123;Name:Tom&#125;&#125;</code></pre></blockquote><p><strong>Q14 Go 语言中如何表示枚举值(enums)</strong></p><blockquote><pre><code class="go">type StuType int32const (    Type1 StuType = iota    Type2    Type3    Type4)func main() &#123;    fmt.Println(Type1, Type2, Type3, Type4) // 0, 1, 2, 3&#125;</code></pre><p>通常使用常量（const）来表示枚举</p></blockquote><p><strong>Q15 空 struct{} 的用途</strong></p><blockquote><ul><li><p>使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值</p></li><li><p>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。</p></li><li><p>使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</p></li><li><p>再比如，声明只包含方法的结构体。</p></li></ul></blockquote><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><strong>Q1 init() 函数是什么时候执行的</strong></p><blockquote><p><code>init()</code> 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</p><p>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 <code>init()</code> 函数。同一个包，甚至是同一个源文件可以有多个 <code>init()</code> 函数。<code>init()</code> 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 <code>init()</code> 函数的执行顺序不作保证。</p><p>一句话总结： import –&gt; const –&gt; var –&gt; <code>init()</code> –&gt; <code>main()</code></p></blockquote><p><strong>Q2 Go 语言的局部变量分配在栈上还是堆上</strong></p><blockquote><p>由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的<strong>作用域没有超出函数范围</strong>，就可以在栈上，反之则必须分配在堆上。</p><pre><code class="go">func foo() *int &#123;    v := 11    return &amp;v&#125;func main() &#123;    m := foo()    println(*m) // 11&#125;</code></pre><p><code>foo()</code> 函数中，如果 v 分配在栈上，foo 函数返回时，<code>&amp;v</code> 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值</p></blockquote><p><strong>Q3 2 个 interface 可以比较吗</strong></p><blockquote><p>Go 语言中，interface 的内部实现包含了 2 个字段，类型 <code>T</code> 和 值 <code>V</code>，interface 可以使用 <code>==</code> 或 <code>!=</code> 比较。2 个 interface 相等有以下 2 种情况</p><p>1、两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）</p><p>2、类型 V 相同，且对应的值 V 相等。</p><pre><code class="go">type Stu struct &#123;    Name string&#125;type StuInt interface&#123;&#125;func main() &#123;    var stu1, stu2 StuInt = &amp;Stu&#123;&quot;Tom&quot;&#125;, &amp;Stu&#123;&quot;Tom&quot;&#125;    var stu3, stu4 StuInt = Stu&#123;&quot;Tom&quot;&#125;, Stu&#123;&quot;Tom&quot;&#125;    fmt.Println(stu1 == stu2) // false    fmt.Println(stu3 == stu4) // true&#125;</code></pre><p><code>stu1</code> 和 <code>stu2</code> 对应的类型是 <code>*Stu</code>，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。<br><code>stu3</code> 和 <code>stu3</code> 对应的类型是 <code>Stu</code>，值是 Stu 结构体，且各字段相等，因此结果为 true。</p></blockquote><p><strong>Q4 两个 nil 可能不相等吗？</strong></p><blockquote><p>可能</p><p>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 <code>T</code> 和 值 <code>V</code>。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。</p><pre><code class="go">func main() &#123;    var p *int = nil    var i interface&#123;&#125; = p    fmt.Println(i == p) // true    fmt.Println(p == nil) // true    fmt.Println(i == nil) // false&#125;</code></pre><p>这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为<code>(T=*int, V=nil)</code>，i 与 p 作比较时，将 p 转换为接口后再比较，因此 <code>i == p</code>，p 与 nil 比较，直接比较值，所以 <code>p == nil</code>。</p><p>但是当 i 与 nil 比较时，会将 nil 转换为接口 <code>(T=nil, V=nil)</code>，与i <code>(T=*int, V=nil)</code> 不相等，因此 <code>i != nil</code>。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil</p></blockquote><p><strong>Q5 简述 Go 语言GC(垃圾回收)的工作原理</strong></p><blockquote><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。<br>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象。</li><li>灰色：存活对象，子对象待处理。</li><li>黑色：存活对象</li></ul><p>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><pre><code>A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)</code></pre><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><pre><code>A (黑) -&gt; B (灰) -&gt; C (白)   ↓ D (白)</code></pre><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)</li><li>2）使用三色标记法标记（Marking, 并发）</li><li>3）标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>4）清理(Sweeping, 并发)</li></ul></blockquote><p><strong>Q6 函数返回局部变量的指针是否安全</strong></p><blockquote><p>这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。</p></blockquote><p><strong>Q7 非接口非接口的任意类型 T() 都能够调用 <code>*T</code> 的方法吗？反过来呢？</strong></p><blockquote><ul><li>一个T类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型<code>*T</code>声明的方法。</li><li>反过来，一个<code>*T</code>类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型<code>*T</code>自动隐式声明一个同名和同签名的方法。</li></ul><p>哪些值是不可寻址的呢？</p><ul><li>字符串中的字节；</li><li>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；</li><li>常量；</li><li>包级别的函数等。</li></ul><p>举一个例子，定义类型 T，并为类型 <code>*T</code> 声明一个方法 <code>hello()</code>，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</p><pre><code class="go">type T stringfunc (t *T) hello() &#123;    fmt.Println(&quot;hello&quot;)&#125;func main() &#123;    var t1 T = &quot;ABC&quot;    t1.hello() // hello    const t2 T = &quot;ABC&quot;    t2.hello() // error: cannot call pointer method on t&#125;</code></pre></blockquote><hr><h4 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h4><p><strong>Q1 无缓冲的 channel 和 有缓冲的 channel 的区别</strong></p><blockquote><p>对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。</p><p>对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。</p><pre><code class="go">func main() &#123;    st := time.Now()    ch := make(chan bool)    go func ()  &#123;        time.Sleep(time.Second * 2)        &lt;-ch    &#125;()    ch &lt;- true  // 无缓冲，发送方阻塞直到接收方接收到数据。    fmt.Printf(&quot;cost %.1f s\n&quot;, time.Now().Sub(st).Seconds())    time.Sleep(time.Second * 5)&#125;</code></pre><pre><code class="go">func main() &#123;    st := time.Now()    ch := make(chan bool, 2)    go func ()  &#123;        time.Sleep(time.Second * 2)        &lt;-ch    &#125;()    ch &lt;- true    ch &lt;- true // 缓冲区为 2，发送方不阻塞，继续往下执行    fmt.Printf(&quot;cost %.1f s\n&quot;, time.Now().Sub(st).Seconds()) // cost 0.0 s    ch &lt;- true // 缓冲区使用完，发送方阻塞，2s 后接收方接收到数据，释放一个插槽，继续往下执行    fmt.Printf(&quot;cost %.1f s\n&quot;, time.Now().Sub(st).Seconds()) // cost 2.0 s    time.Sleep(time.Second * 5)</code></pre></blockquote><p><strong>Q2 什么是协程泄露(Goroutine Leak)</strong></p><blockquote><p>协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：</p><ul><li><p>缺少接收器，导致发送阻塞</p><p>每执行一次 query，则启动1000个协程向信道 ch 发送数字 0，但只接收了一次，导致 999 个协程被阻塞</p></li></ul><pre><code class="go">func query() int &#123;    ch := make(chan int)    for i := 0; i &lt; 1000; i++ &#123;        go func() &#123; ch &lt;- 0 &#125;()    &#125;    return &lt;-ch&#125;func main() &#123;    for i := 0; i &lt; 4; i++ &#123;        query()        fmt.Printf(&quot;goroutines: %d\n&quot;, runtime.NumGoroutine())    &#125;&#125;</code></pre><ul><li><p>缺少发送器，导致接收阻塞</p><p>启动 1000 个协程接收信道的信息，但信道并不会发送那么多次的信息，也会导致接收协程被阻塞，不能退出。</p></li><li><p>死锁(dead lock)</p><p>两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出</p></li><li><p>无限循环(infinite loops)</p><p>为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏。</p></li></ul><pre><code class="go">func request(url string, wg sync.WaitGroup) &#123;    for &#123;        if _, err := http.Get(url); err == nil &#123;            // write to db            break        &#125;        time.Sleep(time.Second)    &#125;    wg.Done()&#125;func main() &#123;    var wg sync.WaitGroup    for i := 0; i &lt; 1000; i++ &#123;        wg.Add(1)        go request(fmt.Sprintf(&quot;exampe.com/%d&quot;, i), wg)    &#125;    wg.Wait()&#125;</code></pre></blockquote><p><strong>Q3 Go 可以限制运行时操作系统线程的数量吗</strong></p><blockquote><p>可以使用环境变量 <code>GOMAXPROCS</code> 或 <code>runtime.GOMAXPROCS(num int)</code> 设置.</p><pre><code class="go">runtime.GOMAXPROCS(1) // 限制同时执行Go代码的操作系统线程数为 1</code></pre><p>从官方文档的解释可以看到，<code>GOMAXPROCS</code> 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。<code>GOMAXPROCS</code> 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。</p></blockquote><hr><h4 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h4><p><strong>常量与变量</strong></p><blockquote><pre><code class="go">func main() &#123;    const (        a, b = &quot;golang&quot;, 100        d, e     //等价于 a, b = &quot;golang&quot;, 100        f bool = true        g        //等价于 f bool = true    )    fmt.Println(d, e, g)&#125;</code></pre><p>在同一个 const group 中，如果常量定义与前一行的定义一致，则可以省略类型和值。编译时，会按照前一行的定义自动补全。即等价于</p></blockquote><blockquote><pre><code class="go">func main() &#123;    const N = 100    var x int = N    const M int32 = 100       var y int = M    //cannot use M (type int32) as type int in assignment    fmt.Println(x, y)&#125;</code></pre><p>Go 语言中，常量分为无类型常量和有类型常量两种，<code>const N = 100</code>，属于无类型常量，赋值给其他变量时，如果字面量能够转换为对应类型的变量，则赋值成功，例如，<code>var x int = N</code>。但是对于有类型的常量 <code>const M int32 = 100</code>，赋值给其他变量时，需要类型匹配才能成功，所以显示地类型转换：</p><pre><code class="go">var y int = int(M)</code></pre></blockquote><blockquote><pre><code class="go">func main() &#123;    var a int8 = -1    var b int8 = -128 / a    fmt.Println(b)&#125;</code></pre><p>int8 能表示的数字的范围是 [-2^7, 2^7-1]，即 [-128, 127]。-128 是无类型常量，转换为 int8，再除以变量 -1，结果为 128，常量除以变量，结果是一个变量。变量转换时允许溢出，符号位变为1，转为补码后恰好等于 -128。</p></blockquote><blockquote><pre><code class="go">func main() &#123;    const a int8 = -1    var b int8 = -128 / a    fmt.Println(b)&#125;</code></pre><p>编译失败：constant 128 overflows int8</p><p>-128 和 a 都是常量，在编译时求值，-128 / a = 128，两个常量相除，结果也是一个常量，常量类型转换时不允许溢出，因而编译失败。</p></blockquote><p><strong>作用域</strong></p><blockquote><pre><code class="go">func main() &#123;    var err error    if err == nil &#123;        err := fmt.Errorf(&quot;err&quot;)        fmt.Println(1, err)    &#125;    if err != nil &#123;        fmt.Println(2, err)    &#125;&#125;</code></pre><p><code>:=</code> 表示声明并赋值，<code>=</code> 表示仅赋值。</p><p>变量的作用域是大括号，因此在第一个 if 语句 <code>if err == nil</code> 内部重新声明且赋值了与外部变量同名的局部变量 err。对该局部变量的赋值不会影响到外部的 err。因此第二个 if 语句 <code>if err != nil</code> 不成立。所以只打印了 <code>1 err</code></p></blockquote><p><strong>defer 延迟调用</strong></p><blockquote><pre><code class="go">type T struct&#123;&#125;func (t T) f(n int) T &#123;    fmt.Print(n)    return t&#125;func main() &#123;    var t T    defer t.f(1).f(2)    fmt.Print(3)&#125;</code></pre><p>defer 延迟调用时，需要保存函数指针和参数，因此<strong>链式调用的情况下</strong>，除了最后一个函数/方法外的函数/方法都会在调用时直接执行。也就是说 <code>t.f(1)</code> 直接执行，然后执行 <code>fmt.Print(3)</code>，最后函数返回时再执行 <code>.f(2)</code>，因此输出是 132。</p></blockquote><blockquote><pre><code class="go">func f(n int) &#123;    defer fmt.Println(n)    n += 100&#125;func main() &#123;    f(1)&#125;</code></pre><p>打印 1 而不是 101。defer 语句执行时，会将需要延迟调用的函数和参数保存起来，也就是说，执行到 defer 时，参数 n(此时等于1) 已经被保存了。因此后面对 n 的改动并不会影响延迟函数调用的结果</p></blockquote><blockquote><pre><code class="go">func main() &#123;    n := 1    defer func() &#123;        fmt.Println(n)    &#125;()    n += 100&#125;</code></pre><p>匿名函数没有通过传参的方式将 n 传入，因此匿名函数内的 n 和函数外部的 n 是同一个，延迟执行时，已经被改变为 101。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/23/hello-world/"/>
      <url>/2021/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> 2222 </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
